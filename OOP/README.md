

# 객체지향 프로그래밍이란?

- OOP
  - 객체를 기반으로 하는 프로그래밍
  - 객체를 정의하고 객체의 기능을 구현하며 객체간의 협력을 구현



- 클래스
  - 객체를 코드로 구현한 것
  - 객체 지향 프로그래밍의 가장 기본요소
- 맴버 변수
  - 객체가 가지는 속성을 변수로 표현
  - 클래스의 맴버 변수
  - member variable , property, attribute
- 매서드
  - 객체의 기능을 구현
  - Method , member function
- 클래스 안에 Public 은 한개만 있어야한다.



# 함수란? 

### 함수

- 하나의 기능을 수행하는 일련의 코드
- 함수를 호출하여 사용하고 기능이 수행된 후 값을 반환 할 수 있음
- 함수로 구현된 기능은 여러 곳에서 호출되어 사용될 수 있음
- 함수는 이름, 매개변수 , 반환값, 함수 몸체(body)로 구성된다.

### 메소드

- 객체의 기능을 구현하기 위해 클래스 내부에 사용되는 함수

### 인스턴스

- 클래스로 부터 생성된 객체
- 힙 메모리에 멤버 변수의 크기에 따라 메모리가 생성
- 클래스를 기반으로 new 키워드를 이용하여 여러 개의 인스턴스를 생성

### 참조 변수

- 메모리에 생성된 인스턴스를 가리키는 변수

### 참조 값

- 생성된 인스턴스의 메모리 주소 값

#### 클래스안에 main 함수가 있다하더라도 메인은 메서드가 아니다.

### 생성자

- 객체를 생성할때 new 키워드와 함께 호출(객체 생성외에는 호출x)
- 인스턴스를 초기화 하는 코드가 구현됨
- 반환 값이 없음 , 상속되지 않음
- 생성자는 클래스 이름과 같다.



### 기본 생성자

- 하나의 클래스에 반드시 하나 이상의 생성자가 존재해야함
- 프로그래머가 생성자를 구현하지 않으면 컴파일러가 생성자 코드를 넣어줌 ->기본생성자
- 기본생성자는 매개 변수가 없고 구현부가 없음
- 만약 클래스에 다른 생성자가 있는경우 디폴트 생성자는 생성되지 않음

### 오버로딩

- 생성자 오버로딩
  - 생성자를 두 개 이상 구현하는 경우
  - 사용하는 코드에서 여러 생성자 중 선택하여 사용할 수 있음
  - Private 변수도 생성자를 이용하여 초기화를 할 수 있음



### 참조 자료형

- 기본적으로 제공하는 자료형이외에 선언할수있는 자료형(ex Student ,,등)



### 정보은닉

- 변수, 메서드 , 생성자에 대한 접근 권한 지정
- public , private, protected, 아무것도 안쓰는 경우(기본접근제어자)
- Private를 사용하면 클래스 외부에서는 접근 할 수 없음

### This

- 자신의 메모리를 가리킴
- 생성자에서 다른 생성자를 호출함
- 인스턴스 자신의 주소를 반환



### 객체간 협력

- 객체 지향 프로그램은 객체를 정의하고 객체간 협력을 구현한 프로그램

  

### Static 변수

- 여러 인스턴스가 하나의 값을 공유할 필요가 있음
- static 변수는 처음 프로그램이 로드될때 데이터 영역에 생성되기때문에 인스턴스 생성과 상관없이 사용할 수 있으므로 클래스 이름으로 참조
- 클래스변수 , 정적 변수라고도 함



### 상속

- 클래스에서 상속의 의미

  - 새로운 클래스를 정의할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능이 확장되는 클래스를 구현함

- 상속하는 클래스 = 상위 클래스

  - parent class , base class , super class

- 상속 받는 클래스 = 하위 클래스

  - Child class , derived class , subclass

    

- C++은 다중상속이 가능하지만 자바는 되지 않는다.

- 상위 클래스는 하위 클래스보다 일반적인 개념과 기능을 가진다.

- 하위 클래스는 상위 클래스보다 구체적인 개념과 기능을 가진다

- **하위 클래스가 생성되는 과정**

  - 하위 클래스가 생성 될때 상위 클래스가 먼저 생성 됨
  - 상위 클래스의 생성자가 호출되고 하위 클래스의 생성자가 호출됨
  - **하위 클래스의 생성자에서는 무조건 상위클래스의 생성자가 호출**되어야 함
  - 하위 클래스에서 상위 클래스의 생성자를 호출하는 코드가 없는 경우 컴파일러는 상위 클래스 기본생성자를 호출하기위한 super()를 추가한다.
  - super()로 호출되는 생성자는 상위 클래스의 기본 생성자임
  - 만약 상위 클래스의 기본생성자가 없는 경우 하위 클래스는 명시적으로 상위 클래스의 생성자를 호출해야함
  - 상위 클래스의 인스턴스가 먼저 생성이 되고 하위 클래스의 인스턴스가 생성되어서 힙메모리에 잡히게 된다.
  - 상위클래스로의 묵시적 형변환인 업캐스팅은 가능하다 반대는 불가  

  

- 오버라이딩

  - 상위 클래스에 정의된 메서드의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름의 매서드를 재정의 할 수 있음
  - 오버로딩과의 차이점은 오버로딩은 메소드 이름은 똑같지만 매개변수가 다른것
  - @override
    - 재정의된 메서드라는 정보 제공
  - @FunctionalInterface
    - 함수형 인터페이스라는 정보 제공
  - @Deprecated
    - 이전 버전에서 사용되지 않을 수 있는 변수 , 메서드에 사용
  - SuppressWarnings
    - 특정 경고가 나타나지 않도록함

- ### 다형성

  - 하나의 코드가 여러 자료형으로 구현되어 실행되는 것

- ### 하위클래스로 형 변환 , 다운캐스팅

  - 묵시적으로 상위 클래스 형변환된 인스턴스가 원래 자료형으로 (하위클래스) 으로 변환되어야 할때 다운 캐스팅이라함
  - 하위 클래스로의 형 변환은 명시적으로 되어야 함

- ### 추상클래스

  - 추상 메서드를 포함한 클래스
  - 추상메서드
    - 구현 코드가 없이 선언부만 있는 메소드
  - abstract예약어 사용
    - 추상클래스는 new(인스턴스화) 할 수 없음

- ### 템플릿 메서드

  - 템플릿 : 틀이나 견본을 의미
  - 템플릿 메서드 : 추상 메서드나 구현된 메서드를 활용하여 전체의 흐름을 정의해 놓은 메서드(final로 선언하여 재정의 할 수 없게 함)
  - 템플릿 메서드 패턴: 디자인 패턴의 일종
    - 프레임 워크에서 많이 사용되는 설계패턴
    - 추상클래스로 선언된 상위 클래스에서 추상메서드를 이용하여 전체구현의 흐름을 정의하고 구체적인 각 메서드 구현은 하위 클래스에 위임함
    - 하위 클래스가 다른 구현을 했다고해서 템플릿 메서드에 정의된 시나리오대로 수행됨

- ### 인터페이스 

  - 추상메서드로만 구성이된다.
  - 상수
  - 디폴트 메서드 : 기본구현을 가지는 메서드 , 구현하는 클래스에서 재정의할수 있음
  - 정적 메서드 : 인스턴스 생성과 상관없이 인터페이스 타입으로 호출하는 메서드
  - private 메서드 : 인터페이스 내에서 사용하기위해 구현한 메서드 , 클래스에서 재정의 안됨

- ### 인터페이스의 역할은

  - 인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 알려주는 명세 혹은 약속
  - 한 객체가 어떤 인터페이스의 탕닙이라 함은 그 인터페이스의 메서드를 구현했다는 것이다.
  - 클라이언트 프로그램은 실제 구현내용을 몰라도 인터페이스의 정의만 알면 그 객체를 사용할 수 있음
  - 인터페이스를 구현해 놓은 다양한 객체를 사용함
    - 다형성 ,JDBC를 구현한 오라클, MSSQL 라이브러리
  - 인터페이스는 구현코드가 없으므로 하나의 클래스가 여러 인터페이스를 구현할 수 있음
    - 디폴트 메서드의 이름이 중복되는 경우에는 재정의함
  - 인터페이스 간에도 상속이 가능함
    - 구현이 없으므로 extends뒤에 여러가지 인터페이스가 나올수 있다.
    - 구현 내용이 없으므로 타입 상속 이라고 함

- ### Object 클래스

  - 모든 클래스의 최상위 클래스

  - Java.lang.object 클래스

  - 모든 클래스는 object클래스에서 상속받음

  - 모든 클래스는 object클래스의 메서드를 사용할 수 있음

  - 모든 클래스는 object클래스의 일부 메서드를 재정의하여 사용할 수 있음

  - ### HashCode()메서드

    - hashCode()메서드의 반환 값 : 인스턴스가 저장된 가상머신의 주소를 10진수로 반환
    - 두개의 서로 다른 메모리에 위치한 인스턴스가 동일하다는 것은?
      - 논리적으로 동일: equals()의 반환값이 true
      - 동일한 hashcode 값을 가짐 : hashCode()의 반환값이 동일

  - ### Clone()메서드

    - 객체의 복사본을 만듦
    - 기본틀(prototype)으로부터 같은 속성 값을 가진 객체의 복사본을 생성 할 수 있음
    - 객체지향 프로그래밍의 정보은닉에 위배되는 가능성이 있으므로 복제할 객체는 cloneable인터페이스를 명시해야함

- ### Class 클래스

  - 자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성됨
  - class 파일에는 객체의 정보(멤버변수 , 메서드 , 생성자등) 가 포함되어있다.
  - Class 클래스는 컴파일된 class 파일에서 객체의 정보를 가져올 수 있음
  - String s = new String();
  - Class c = s.getClass();
  - Class c = String.class;
  - Class c = Class.forName("java.lang.string"); // 동적 로딩
  - Reflection 프로그래밍
    - class 클래스로부터 객체의 정보를 가져와 프로그래밍 하는 방식
    - 로컬에 객체가 없고 자료형을 알 수 없는 경우 유용한 프로그래밍
    - java.lang.reflect패키지에 있는 클래스 활용

- ### String 클래스

  - string 클래스 선언하기

    - String str1 = new String("abc")

  - String값은 immutable하다. string class 를 찾아보게되면 final이기때문에 변하지 않는 값이다.

  - ### String Builder 와 String buffer

    - 가변적인 char[] 배열을 멤버변수로 가지고 있는 클래스
    - 문자열을 변경하거나 연결하는 경우 사용하면 편리한 클래스
    - String buffer는 멀티 쓰레드 프로그래밍에서 동기화(Synchronization)이 보장됨
    - 단인 쓰레드 프로그래밍에서는 StringBuilder를 사용하는 것이 더 좋음
    - toString() 메서드로 String반환

- ### 제네릭 프로그래밍이란

  - 변수의 선언이나 메서드의 매개변수를 하나의 참조자료형이 아닌 여러 자료형을 변환될수있도록 프로그래밍하는 방식
  - 실제 사용되는 참조 자료형으로 변환은 컴파일러가 검증하므로 안정적인 프로그래밍 방식

- ### 컬렉션 프레임 워크란

  - 프로그램 구현에 필요한 자료구조와 알고리즘을 구현해 놓은 라이브러리
  - java.util 패키지에 구현되어 있음
  - 개발에 소요되는 시간을 절약하고 최적화된 라이브러리를 사용할 수있음
  - Collection 인터페이스와 map 인터페이스로 구성됨
  - Collection 인터페이스
    - 하나의 객체의 관리를 위해 선언된 인터페이스로 필요한 기본 메서드가 선언되어있음
    - Collection 하위에 list와 set이있다.
    - list의 하위에는 Arraylist , vector , linkedList
    - set의 하위에는 hashSet , TreeSet이 잇다.
    - List 인터페이스는 순서가있는 자료관리 , 중복허용 stack , queue
    - set인터페이스는 순서가 정해져있지않음 , 중복불허용
  - Map 인터페이스 
    - hashtable , hashmap , treemap으로 구성됨
    - 쌍으로 이루어진 객체를 관리하는데 필요한 여러 메서드가 선언되어있음
    - map을 사용하는 객체는 key-value쌍으로 되어있고 key는 증복될수 없음

- ### List 인터페이스

  - 객체를 순서에 따라 저장및 관리
  - 배열의 기능을 구현하는 것
  - ArrayList vs Vector
    - 벡터는 멀티쓰레드 프로그램에서 동기화를 지원
      - 동기화란 : 두개의 쓰레드가 동시에 하나의 리소스에 접근할때 순서를 맞추어서 데이터의 오류가 방지하지 않도록함
    - capacity와 size는 다른 의미임
      - capacity는 배열의 용량 , size는 요소의 개수

- ### Iterator로 순회하기

  - collection의 개체를 순회하는 인터페이스
  - iterator()메서드 호출
    - iterator ir = memberArrayList.iterator();

- ### TreeSet클래스

  - 객체의 정렬에 사용되는 클래스
  - 중복을 허용하지 않으면서 오름차순이나 내림차순 객체를 정렬함
  - 내부적으로는 이진검색트리로 구현되어있음
  - 이진검색트리에 자료가 저장될때 비교하여 저장될 위치를 정함
  -  객체를 비교하기위 해 comparable이나 comparator 인터페이스를 구현해야함

- ### Map 인터

- ### 페이스

  - Key-value pair의 객체를 관리하는데 필요한 메서드가 정의됨
  - key는 중복될 수 없다.
  - 검색을 위한 자료구조
  - key를 이용하여 값을 저장하거나 , 검색, 삭제 할때 사용하면 편리함
    - 내부적으로 hash 방식으로 구현됨
  - key가 되는 객체는 객체의 유일성함의 여부를 알기위해 equls와 hashcode메서드를 재정의함

- ### 내부클래스

  - 클래스의 내부에 구현한 클래스(중첩된 클래스)
  - 클래스 내부에서 사용하기 위해서 선언하고 구현하는 클래스
  - 주로 외부 클래스 생성자에서 내부 클래스를 생성
    - 인스턴스 내부클래스
    - 정적 내부 클래스
    - 지역 내부 클래스
    - 익명 내부 클래스(가장 많이 사용하는 클래스)

- ### 람다식이란?

  - 자바에서 함수형 프로그래밍을 구현하는 방식
  - 클래스를 생성하지 않고 함수의 호출만으로 기능을 수행
  - 함수형 인터페이스를 선언함
  - 자바 8부터 지원되는 기능
  - 순수함수를 사용한다.

- ### 스트림

  - 자료의 대상과 관계없이 동일한 연산을 수행할 수 있는 기능( 자료의 추상화)
  - 배열, 컬렉션에 동일한 연산이 수행되어 일관성 있는 처리기능
  - 한번생성하고 사용한 스트림은 재사용할 수 없음
  - 스트림 연산은 기존 자료를 변경하지 않음
  - 중간 연산과 최종 연산으로 구분됨
  - 최종 연산이 수행되어야 모든 연산이 적용되는 지연 연산
  - 중간연산
    - filter() , map()
    - 조건에 맞는 요소를 추출하거나 요소를 변환함(filter, map)
  - 최종연산
    - 재활용이 불가능하다.
    - 스트림의 자료를 소모하면서 연산을 수행
    - 최종 연산 후에 스트림은 더이상 다른 연산을 적용할 수 없음
    - ForEach() : 요소를 하나씩 꺼내옴
    - count() : 요소의 개수
    - sum() : 요소의 합
    - 등등
    - 

